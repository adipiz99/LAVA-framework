import re
import torch
import random
from pathlib import Path
from torch.utils.data import Dataset

class CodecFakeMultiClassDataset(Dataset):
    """
    PyTorch Dataset for loading CodecFake deepfake audio samples with automatic class extraction.
    
    This dataset is specifically designed for the CodecFake dataset, which contains deepfake
    audio samples generated by different models. It automatically extracts class labels from
    filename patterns and provides samples ready for multi-class classification tasks.
    
    The dataset expects files named with pattern containing "F01", "F02", ..., "F06" where
    the number indicates the generation model used (6 different deepfake models).
    
    Parameters:
    -----------
    root_dir : str or Path
        Root directory containing .pt files (preprocessed audio tensors)
    seed : int, optional (default=None)
        Random seed for reproducible shuffling of samples
        If None, uses system random state
        
    File Naming Convention:
    -----------------------
    Files should follow pattern: "...F{model_number}_..."
    Examples:
    - sample_F01_audio.pt → Class 1 (model 1)
    - sample_F02_audio.pt → Class 2 (model 2)
    - sample_F06_audio.pt → Class 6 (model 6)
    
    Label Processing:
    -----------------
    - Extracts labels 1-6 from filenames
    - Automatically converts to 0-based indexing (1→0, 2→1, ..., 6→5)
    - Suitable for PyTorch classification models expecting 0-based classes
    
    Dataset Statistics:
    -------------------
    Prints during initialization:
    - Number of samples per class (1-6)
    - Total number of samples found
    - Helps verify dataset balance and completeness
    
    Data Format:
    ------------
    - Input files: .pt files containing preprocessed audio tensors
    - Tensors are automatically converted to float type
    - Expected tensor shape: [channels, time_steps] for audio
    
    Returns:
    --------
    tuple: (tensor, label)
        tensor : torch.Tensor
            Audio tensor loaded from .pt file (converted to float)
        label : int
            Zero-based class label (0-5 for models 1-6)
            
    Raises:
    -------
    ValueError
        If no valid .pt files found or unable to extract labels from filenames
        
    Usage:
    ------
    # Basic usage
    dataset = CodecFakeMultiClassDataset(
        root_dir="/path/to/CodecFake_processed/fake_processed"
    )
    
    # With reproducible shuffling
    dataset = CodecFakeMultiClassDataset(
        root_dir="/path/to/CodecFake_processed/fake_processed",
        seed=42
    )
    
    # Use with DataLoader
    from torch.utils.data import DataLoader
    dataloader = DataLoader(dataset, batch_size=16, shuffle=True)
    
    # Access samples
    audio_tensor, model_label = dataset[0]
    print(f"Audio shape: {audio_tensor.shape}")
    print(f"Generation model: {model_label + 1}")  # Convert back to 1-based
    
    Expected Directory Structure:
    -----------------------------
    root_dir/
    ├── F01_audio.pt  # Model 1 samples
    ├── sample2_F01_audio.pt
    ├── sample3_F02_audio.pt  # Model 2 samples
    ├── sample4_F02_audio.pt
    ├── ...
    └── sampleN_F06_audio.pt  # Model 6 samples
    
    Applications:
    -------------
    - ADMR (Audio Deepfake Model Recognition) tasks
    - Multi-class classification of generation models
    - Training models to identify deepfake generation techniques
    - Forensic analysis of synthetic audio
    """
    def __init__(self, root_dir, seed=None):
        self.samples = []
        root = Path(root_dir)

        for file_path in sorted(root.glob("*.pt")):
            match = re.search(r"F(\d+)_", file_path.name)
            if match:
                label = int(match.group(1))
                self.samples.append((file_path, label))

        # Print the number of samples for each class
        class_counts = {}
        for _, label in self.samples:
            if label in class_counts:
                class_counts[label] += 1
            else:
                class_counts[label] = 1
        for label, count in class_counts.items():
            print(f"Class {label}: {count} samples")
        # Print the total number of samples
        print(f"Total samples: {len(self.samples)}")

        # Shuffle the samples
        if seed is not None:
            rng = random.Random(seed)
            rng.shuffle(self.samples)
        else:
            random.shuffle(self.samples)


        if not self.samples:
            raise ValueError("No valid .pt files found or unable to extract labels.")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        path, label = self.samples[idx]
        tensor = torch.load(path).float()
        label = label - 1  # Convert to zero-based index for classification tasks
        return tensor, label

